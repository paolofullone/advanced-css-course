/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

*,
*::after *::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
  /* we are forcing the box-sizing to each and every element on the page do inherit what we put in the body, the box-sizing: border-box was here and we moved to body. */
  /* we updated the * with also the ::after and ::before elements, because only the real elements get the behavior if we use only *, now with the pseudo-elements any rule applied using pseudo elements will also inherit and receive the global reset. */
}

html {
  /* font-size: 10px; */
  /* people ho has bad sight increases the font size of their browsers, if we set to 10pixels we are disabling this feature of the user, so we set in percentage to the equivalent of 10 pixes, 10/16 = 0.625, if the user changes it will affect the entire page */
  font-size: 62.5%;
}

body {
  font-family: 'Lato', sans-serif;
  /* we allways set the font in the body, not in the universal selector */
  /* Lato was imported from google fonts in html */
  font-weight: 400;
  /* font-size: 16px; now we will use the html to set the font-size to 10pixel acc. to class 18, so it becomes totally responsive. */
  line-height: 1.7;
  color: #777;
  /* padding: 30px; converting to rem*/
  padding: 3rem;
  /* this adds a nice border to entire web page */
  box-sizing: border-box;
  /* paddings and borders are not added to height and width */
}

.header {
  height: 95vh;
  /* size of 95% of viewport height */
  /* background-image: url(../img/hero.jpg); */
  /* if we type backimg vscode finds background-image:` */
  background-image: linear-gradient(
      to right bottom,
      rgba(126, 213, 111, 0.8),
      rgba(40, 180, 133, 0.8)
    ),
    url(../img/hero.jpg);
  /* this sets two background images, one in top of the other, first one is a gradient image */
  /* 0.8 in the end of rgba sets opacity to 80% */
  /* to change the hex to rgba click on hex and slide the bar  */
  background-size: cover;
  /* this will make the background image try to cover any size of the box */
  /* at this point the background image is already rendered and we see 5% in the bottom*/
  /* of the page not filled with the image. */
  background-position: top;
  /* when we shrink the window, the top remains the same and the bottom is cropped */
  /* we can set to bottom in the inspector and see the difference as we reduce the window */
  /* can also be set to center to crop bottom and top */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* starts at top right, then top left, them bottom left, them bottom right */
  /* the 75vh maintains 75% of the viewport height */
  /* to do a triange (50% 0, 100% 100%, 0 100%) */
  /* https://bennettfeely.com/clippy/ lots of css shapes */
  position: relative;
}

.header__logo-box {
  position: absolute;
  /* top: 40px;
  left: 40px; converting to rem */
  top: 4rem;
  left: 4rem;
  /* the reference of top and left is calculated by the parent element, in this case the header, so we set position: relative in the parent element */
}

.header__logo {
  height: 3.5rem;
  /* height: 35px; converting to rem */
  /* we can only set heigth and the width will be figured out by the browser */
}

/* .logo:hover {
  animation-name: moveInRight;
  animation-duration: 1s;
  animation-timing-function: ease-out;
} */

/* we included a div text-box so we can place the button latter on, included this element here to follow the natural order of the html. */
.header__text-box {
  position: absolute;
  top: 40%;
  /* since we cropped the bottom of the image we decided to put 40% instead of 50% */
  left: 50%;
  /* background-color: fuchsia; */
  transform: translate(-50%, -50%);
  /* with only top and left, it will place the begining of the box 50% to the left and 50% from the top, but not centered, to center we use transform: translate, take translate out and put background color back to check. */
  text-align: center;
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  /* margin-bottom: 60px; converting to rem */
  margin-bottom: 6rem;
}
.heading-primary--main {
  display: block;
  /* display block occupies all the space available and create break lines before and after the element, if we inspect we will see it occupies 100% */
  font-size: 6rem;
  /* font-size: 60px; converting to rem */
  font-weight: 400;
  /* letter-spacing: 30px; converting to rem */
  letter-spacing: 3rem;
  animation-name: moveInLeft;
  animation-duration: 1s;
  animation-timing-function: ease-out;
  /* animation-delay: 1s;
  animation-iteration-count: 3; */
}
.heading-primary--sub {
  display: block;
  /* font-size: 20px; converting to rem */
  font-size: 2rem;
  font-weight: 700;
  /* letter-spacing: 15.6px; converting to rem */
  letter-spacing: 1.56rem;
  /* the letter spacing was adjusted to both texts have the same size */
  animation: moveInRight 1s ease-out;
}

/* .heading-primary-sub:hover {
  animation: moveInRight 1s ease-out;
} */

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

/* To animate anything we will use @keyframes, we can set any percentage and any amount of percentages, we could have 0, 20, 40, 60, 80, 100... */
/* first thing we set invisible with opacity 0 at 0% and visible with opacity 1 at 100% */
/*  translateX(-100px) will move 100px to the left and finish at the exact same position it is settet in the class parameters itself with translate(0)*/
/* we just inserted a 10px at 80% so it goes forth than back, we can also set an delay if we want to. animation iteration count repeats the animation. */
/*  we also have some more additional parameters as ease-in, ease-out, with accelerates more in the beginning or in the end... */

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

/* in the second one we used a shorthand and passed a one liner. */
/* jonas zoomed the video and showed a small shake in the element in the end. no one knows why this happens, to solve we set the   backface-visibility: hidden; in the parend .heading-primary class */
/* the  backface-visibility: hidden would hide a back part of an element if we rotate it 180 degrees as an example. */
/* added some transform: rotate(0deg), rotate(180deg), rotate(2700deg) rotate(0deg) in some percentages just to play around */
/* inserted a .hover:logo to animate the logo on hover, mine was not animating, just flashing fastly.  */

@keyframes moveInBottom {
  0% {
    opacity: 0;
    /* transform: translateY(30px); converting to rem */
    transform: translateY(3rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

.btn:link,
.btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  /* padding: 15px 40px; converting to rem */
  padding: 1.5rem 4rem;
  display: inline-block;
  border-radius: 10rem;
  transition: all 0.2s;
  position: relative;
}

/* we used a :link because this button will be a link, and :link is a pseudo-class */
/* in the browsers a visited link gets purple, we want them to be same as before visiting. */
/* paddin: 10px, 40px, 10px top and bottom, 40px left and right */
/* we set the btn to inline-block so it not overlaps with the header text */
/* since the btn is a inline-block, it is treated as text. so we set the .text-box property in the begining of the code to text-align: center */
/* Also added margin-bottom: 60px in the .heading-primary  */
/* border radius will round the borders of the button */
/* transition is the 2nd method of animation, @keyframes is more complicated one. all means all the properties are enabled to be animated, 0.2s is the time for the transition, we already used the shorthand., the transition property has to be in the initial state. */

.btn:hover {
  transform: translateY(-3rem);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
}

/* with transform: translateY(-3px) will move the btn a little bit up when we hover it. */

.btn:active {
  transform: translateY(-1rem);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
}

/* when we click with tansform: translateY(-1px) it moves a bit down. */
/* box shadow 0 is a shadow in the x direction, here we don't want any shadow in x axis, the 2nd parameter is the shadow, the 3rd is the blur, this will give a impression that when we click we push the button onto the page.  */

.btn--white {
  background-color: #fff;
  color: #777;
}

.btn::after {
  content: '';
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 10rem;
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all 0.4s;
}

/* with after pseudo-element we always have to specify the content, can be an empty string, but we have to specify. */
/* we also have to specify display, so we will use exact the same, the button is already an inline-block element */
/* the after pseudo-element is treated as a child, so we set the 100% of the button width and height to it's "son".  */
/* so we want to put the btn::after behing the actual element, so we use position: abosolute and set the top:0 and left: 0, the position needs to have a reference, it's the first element it can find, in this case would be the header, but we want it to be the button, so we set the position: relative in the button */
/* z-index: -1 because we want it behind the button, so we will implement the hover in the btn. */

.btn--white::after {
  background-color: #fff;
}

.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0;
}
/* after element only when we hover an delement. */
/* at this point we have a 1.5 times button when we hover it */
/* so the initial state of the hover::after is the btn::after element, and we will set the transition state on it */
/* with opacity 0 and transition it will fade out after the time set on transition */
/* adjusted the scale to scaleX(1.4) and scaleY(1.6) */
/* we created the @keyframes moveInBottom and inserted the .btn-animated as a class of the discoverourtours button. */

.btn--animated {
  animation: moveInBottom 0.5s ease-out 0.75s;
  animation-fill-mode: backwards;
}

/* we will set the duration of .5seconds, it will ease-out and will have a delay of .75s related to the others animations */
/* so the button is visible and then it starts the animation, if we set the animation-fill-mode it will automatically applies the styles of the 0% before the animation starts. which in this case is opacity 0. */
/* coment the animations-fill-mode to see what happens. */

/* class 11 - section intro */
/* class 12 - three pillars of writing good html and css => check slides */
/* class 13 - how css is parsed, part 1: the cascade and specificity */
/* the cascade is user !importatn declarations, then author !important, then author > user > browser default values */
/* the specificity is cascaded as inline styles then ids then classes, pseudo-classes and attribute, in the end we have the elements and pseudo elements */
/*  if theres a tie in the specificity the last code written will override the other ones. */
/* the !important must be a last last resource, probably you can solve anything with specificity */
/* inline styles written in html will override any css */
/* a selector with 1 id is more specific than one with 1000 classes */
/* a selector with 1 class is more specific than one with 1000 elements */
/* the universal selector has no specificity selector , it is (0,0,0,0) */
/* Rely more on specificity than on the order of selectors. */
/* when you use 3rd party stylesheeds - always put your author stylesheet last, so it can override the 3rd party */

/* 16 - class How Css Values are processed */
/* in the end, everything (rem, vh...) wil be converted to pixels */
/* rem is also a relative unit, it is relative to the root font size, the browser default font size is 16px */
/* in the given example it had a font-size: 150% in a header, it means it will have a font 150% relative to it's parent element, wich is body in this case */
/* when we express a percentage, the reference is always the parents element, valid for width, padding, fonts... */
/* //* the parent's width is the reference for % based calculations */
/* //* if we set the fonts with em and rem the page is more responsive. */
/* //* vh and vw are simply percentage measurements of the viewport's height and width */
/* //* each css property has a initial value, which is used if no value is defined, no inheritance here  */
/* //* browser usually has 16px root-font-size */
/* //* percentages are measured relative to their parents width if used to specify lengths */
/* //* em are measured relative to their parent font-size, if used to specify font-size */
/* //* em are measured relative to current font-size, if used to specify length */
/* //* rem are always measured relative to the document's root font-size */

/* 17 - inheritance in css */
/* every css property must have a value */
/* when processing a property the 1st question that css engine asks is if there is a cascated value */

/* 18 - convert all units to rem, if we have to do a page to a mobile device, we will be able to change all units changing only in one place. */
/* to make things easier we set the html font size to 10px, so we know that 1 rem is 10pixels */
/* rems are not supported in internet explorer 9 */
/* the technique we used is EXTREMELY DIFICULT with em's, because it depends on the parent's element font-size, not the root font size. */

/* 19 - How CSS Renders a Website - The visual formatting model */
/* Box Model */
/* //* Content - Texto ou imagem */
/* //* Padding - área transparente ao redor do conteúdo, dentro da caixa, uma "margem" dentro da caixa. */
/* //* Border - fica ao redor do padding e do conteúdo */
/* //* a margem é o espaço entre caixas, o que vai separar uma caixa da outra */
/* //* Fill Area é a area que será preenchida com uma imagem ou cor de fundo, inclui o conteúdo, padding, border mas não inclui a margem. */
/* //* Se usarmos o box-sizing: border-box a caixa terá a largura total definido somente pela propriedade width por exemplo */
/* //* Se não for definido o box-sizing, a caixa teria a largura definida por: total width = right border + right padding + specified width + left padding + left border */
/* //* Muito mais fácil definir o tamanho dos elementos usando o box-sizing: border box. */
/* //* Este conceito se aplica somente a block-level boxes, que é somente 1 tipo de caixas no css, vamos ver as 3 mais comums */
/* //* display: block as caixas são posicionadas de forma vertical, uma depois da outra, elas ocupam o máximo de largura possível, normalmente 100% da largura do elemento pai e são formatadas visualmente como blocos */
/* //* parágrafos e divs tem display: block de fábrica. Elas criam quebras de linha antes e depois, por isso são posicionadas de forma vertical */
/* //* display: inline é basicamente o contrário da block, a caixa ocupa somente o espaço que o conteúdo precisa, é distribuida em linhas, não tem quebras de linhas, heigth e width não se aplicam, ou seja, não podemos definir heigth e width para inline box, paddings e margens só são aplicadas a direita e esquerda. As limitações da inline é que nos levam a inline-block */
/* //* inline-block é uma mistura dos dois elementos, tecnicamente é uma caixa inline que funciona como block no interior. Usam somente o seu conteúdo como largura e por isso não provocam quebra de lnha.  */

/* //* Esquemas de posicionamento, temos o normal flow, floats e absolute positioning */
/* //* position: relative é o normal flow, os elementos são dispostos na página de forma natural */
/* //* float: left ou float: right o elemento é retirado do fluxo normal, texto e inline elements vão ser envolvidos ao redor do "floated element", o container não vai ajustar sua altura ao elemento*/
/* //*  position: absolute ou position: fixed o elemento é retirado do fluxo normal, o conteúdo não tem impacto em elementos próximos e pode inclusive se sobrepor a eles. */
/* //* Usamos o top, bottom, left and right para posicionar o elemento em relação ao seu container */
/* //* stacking content é a pilha de elementos na tela, o mais comum é o z-index */
/* //*  uma maneira de empilhar elementos é usar o z-index junto com position. Mostrou um exemplo de 3 elementos empilhados: */
/* z-index: 3 e position: relative, depois um z-index: 2 e position: absolute depois um z-index: 1 e position: relative*/
/* //* Opacidade, filter, transform também vão criar empilhamentos, por isso as vezes mesmo com o uso do z-index não causa o efeito esperado de empilhamento */

/* 20 - Arquitetura CSS, componentes e BEM */
/* //* As decisões no início do projeto vão impactar muito se o site crescer */
/* //* sugere a metodologia do think build architect */
/* //* primeiro pensar no layout do site. antes de escrever uma linha de código */
/* //* em segundo lugar criar o html e o css com uma estrutura consistente de nomes de classes */
/* //* ao final criar a lógica de arquitetura com arquivos e pastas */
/* //* Sugeriu o COMPONENT-DRIVEN-DESIGN */
/* //* THINKING - Blocos modulares para a interface, são integrados pelo layout da página, devem ser reutilizáveis entre vários projetos e seren independentes dos elemetos pai, permitindo que sejam usados em qualquer lugar na página. */
/* //* BUILD - BEM é Block Element Modifier, mostrou um exemplo de uma página de receitas em que o elemento pai tem uma classe "recipe", cada elemento filho tem sua classe específica como recipe__stats_box, recipe__info e o botão por exemplo tem recipe_btn btn btn--round, ou seja, tem classes adicionais. O que é totalmente permitido,mas a classe recipe__info por exemplo não faz sentido fora de uma classe recipe pai. */
/* //* No botão por exemplo tem o btn--round que deixa claro que se trata de um botão arredondado, pode ter outras classes de outros tipos de botão por exemplo  */
/* //* Block é um componente standalone que tem seu significado próprio, Element é parte do bloco que não tem significado próprio e Modifier é uma flag para uma versão diferente do bloco ou elemento */
/* //* sugeriu uma leitura do código para ver que intuitivamente percebe-se como estão relacionadas as classes e o que cada uma faz. */
/* //* BEM é mais verboso, mas traz muitos benefícios em aplicações maiores. */
/* //* Sugeriu o uso da metodologia 7-1, onde temos 7 pastas para arquivos parciais e um arquivo principal onde importamos os outros 7 */
/* //* base / components / layout / pages / themes / abstracts / vendors */
/* //* abstract é uma pasta que colocamos código que não tem um css output, como variáveis ou mix-ins??? */
/* vamos implementar essas pastas nos projetos a medida que foram necessárias, nem sempre usamos todas. */

/* 21 - aplicando o conceito BEM no projeto */

/* Aula 22 e 23 */
/* //* SAAS é um pre-processador, uma extensão do css que adiciona poder e elegância a linguagem */
/* Ao invés de termos apenas um arquivo com muitas linhas de código usamos o saas => compilador saas => css compilado */
/* vamos usar arquivos saas, depois rodar o compiler e o resultado é um arquivo css compilado, o browser recebe apenas o css compilado */
/* saas tem variáveis que podem ser reutilizadas como cores, tamanhos de fontes, espaçamento etc  */
/* também tem  "nesting" que permite aninhar seletores dentro um do outro, permitindo escrever menos código */
/* operators para operações matemáticas no css */
/* partials and imports que permite escrever css em vários arquivos e depois importar todos em um arquivo único */
/* mixins permite reutilizar partes de código "reusable pieces" */
/* funções quer são similares aos mixis, produzem valores que podem ser reaproveitados */
/* extends  permite fazer seletores diferentes herdar declarações que são comuns a todos eles */
/* por fim control directives para escrever códigos mais complexos usando condicionais e loops (não veremos nesse curso) */
/* o saas tem duas sintaxes, uma com uso de { } e outa sem */
/* o saas não usa { } e tem identação */
/* o scss tem os { } e ;, fica mais intuitivo e mais fácil de ler, vamos usar o scss nesse curso */


/* freecodecamp basic course */
/* border-radius: 50% transforma a imagem em uma imagem redonda; */

/* elemento com duas classes, aplica a que for a última no css, não importa a ordem no html */
/* elemento com duas classes e um id, aplica o id, mesmo que ele venha antes das classes no css, não importa a ordem no html */
/* se colocar um inline style vai sobrescrever classes e id's */
/* e o último recurso que é má prática => !important */